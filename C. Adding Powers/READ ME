C. Adding Powers
2 seconds256 megabytesstandard inputstandard output


Suppose you are performing the following algorithm. There is an array ğ‘£1,ğ‘£2,â€¦,ğ‘£ğ‘› filled with zeroes at start. The following operation is applied to the array several times â€” at ğ‘–-th step (0-indexed) you can:

either choose position ğ‘ğ‘œğ‘  (1â‰¤ğ‘ğ‘œğ‘ â‰¤ğ‘›) and increase ğ‘£ğ‘ğ‘œğ‘  by ğ‘˜ğ‘–;
or not choose any position and skip this step.
You can choose how the algorithm would behave on each step and when to stop it. The question is: can you make array ğ‘£ equal to the given array ğ‘ (ğ‘£ğ‘—=ğ‘ğ‘— for each ğ‘—) after some step?

Input
The first line contains one integer ğ‘‡ (1â‰¤ğ‘‡â‰¤1000) â€” the number of test cases. Next 2ğ‘‡ lines contain test cases â€” two lines per test case.

The first line of each test case contains two integers ğ‘› and ğ‘˜ (1â‰¤ğ‘›â‰¤30, 2â‰¤ğ‘˜â‰¤100) â€” the size of arrays ğ‘£ and ğ‘ and value ğ‘˜ used in the algorithm.

The second line contains ğ‘› integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› (0â‰¤ğ‘ğ‘–â‰¤1016) â€” the array you'd like to achieve.

Output
For each test case print YES (case insensitive) if you can achieve the array ğ‘ after some step or NO (case insensitive) otherwise.

Example
inputCopy
5
4 100
0 0 0 0
1 2
1
3 4
1 4 1
3 2
0 1 3
3 9
0 59049 810
outputCopy
YES
YES
NO
NO
YES
Note
In the first test case, you can stop the algorithm before the 0-th step, or don't choose any position several times and stop the algorithm.

In the second test case, you can add ğ‘˜0 to ğ‘£1 and stop the algorithm.

In the third test case, you can't make two 1 in the array ğ‘£.

In the fifth test case, you can skip 90 and 91, then add 92 and 93 to ğ‘£3, skip 94 and finally, add 95 to ğ‘£2.

;
